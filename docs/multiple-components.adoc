= Deploying multiple components

==== Introduction

This application you will be deploying is a wild west shooter style game.

Applications are often divided into components based on a logical division of labor. For example, an application might consist of a data-storage, backend component that performs the application's primary work and stores the results. The backend component is paired with a user interface, frontend component that accesses the backend to retrieve data and displays it to a user.

We will deploy this tutorial with two such components.

**Frontend:**
The frontend is the user interface for a wild west style game written in Node.js. It displays popup images which you can shoot, corresponding to the resource objects returned by the backend.

**Backend:**
The backend is a Java-based Spring Boot application. It performs queries against the Kubernetes and OpenShift REST APIs to retrieve a list of the resource objects that were created when you deployed the application. Then, it returns details about these resource objects to the frontend.

=== Creating an initial project

We need to log in to OpenShift:

[source,bash]
----
$ odo login -u developer -p developer
----

Create a new directory and download both the backend and frontend applications:

[source,bash]
----
$ mkdir wild-west
$ cd wild-west
$ git clone https://github.com/openshift-evangelists/Wild-West-Backend backend 
$ git clone https://github.com/openshift-evangelists/Wild-West-Frontend frontend
----

Before we deploy an application, let's change into the directory and create a new project / OpenShift namespace:

[source,bash]
----
$ cd wild-west
$ odo project create myproject
 ✓  Project 'myproject' is ready for use
 ✓  New project created and now using project : myproject
----

Before proceeding, we also have a few requirements:

- Service Catalog enabled within the OpenShift Cluster
- `odo`
- `oc`
- `mvn`

=== Deploying the back-end binary

As mentioned, applications often consist of two or more components that work together to implement the overall application. OpenShift helps organize these modular applications with a concept called, appropriately enough, the application. An OpenShift application represents all of an app's components in a logical management unit. The odo tool helps you manage that group of components and link them together as an application.

A selection of runtimes, frameworks, and other components are available on an OpenShift cluster for building your applications. This list is referred to as the Software Catalog.

==== Prerequisites

List the supported component types in the catalog by running:

[source,bash]
----
$ odo catalog list components      
Odo Supported OpenShift Components:
NAME       PROJECT       TAGS
nodejs     openshift     10,8,8-RHOAR,latest

OpenShift Components:
NAME        PROJECT       TAGS
dotnet      openshift     2.0,latest
httpd       openshift     2.4,latest
nginx       openshift     1.10,1.12,1.8,latest
nodejs      openshift     6
perl        openshift     5.24,5.26,latest
php         openshift     7.0,7.1,latest
python      openshift     2.7,3.5,3.6,latest
ruby        openshift     2.3,2.4,2.5,latest
wildfly     openshift     10.0,10.1,11.0,12.0,13.0,8.1,9.0,latest
----


Administrators can configure the software catalog to determine what components are available in the catalog, so the list will vary on different OpenShift clusters. For this scenario, the cluster's catalog list must include java and nodejs.

For our back-end, we require **Java** to run our applicaton. We will import `openjdk18` into our cluster:

[source,bash]
----
$ oc import-image openjdk18 --from=registry.access.redhat.com/redhat-openjdk-18/openjdk18-openshift --confirm
oc annotate istag/openjdk18:latest tags=builder
----

In order to make the image accesible to `odo`, we will tag the image as `builder`:

[source,bash]
----
$ oc annotate istag/openjdk18:latest tags=builder
----

The next time you run `odo catalog list components`, you will see the newly created image:

[source,bash]
----
$ odo catalog list components
Odo Supported OpenShift Components:
NAME          PROJECT       TAGS
nodejs        openshift     10,8,8-RHOAR,latest
openjdk18     myproject     latest
----

==== Deploying the application

Source code for the backend of our wildwest application is available in the command line environment. Change directories into the source directory, backend:

[source,bash]
----
$ cd ~/backend
----

Take a look at the contents of the backend directory. It's a regular Java Spring Boot application using the Maven build system:

[source,bash]
----
$ ls
debug.sh  pom.xml  src
----

Build the backend source files with Maven to create a jar file:

[source,bash]
----
$ mvn package
...
[INFO] ------------------------------------------------------------------------
[INFO] BUILD SUCCESS
[INFO] ------------------------------------------------------------------------
[INFO] Total time: 2.635 s
[INFO] Finished at: 2019-09-30T16:11:11-04:00
[INFO] Final Memory: 30M/91M
[INFO] ------------------------------------------------------------------------
----

With the backend's .jar file built, we can use odo to deploy and run it atop the Java application server we saw earlier in the software catalog. The command below creates a component configuration of component-type java named backend:

[source,bash]
----
$ odo create openjdk18 backend --binary target/wildwest-1.0.jar
 ✓  Validating component [1ms]
 Please use `odo push` command to create the component with source deployed
---- 

The component is not yet deployed on OpenShift. With an `odo create` command, a configuration file called `config.yaml` has been created in the local directory of the backend component that contains information about the component for deployment.
 
To see the configuration settings of the backend component in config.yaml, odo has a command to display this information:

[source,bash]
----
$ odo config view
COMPONENT SETTINGS
------------------------------------------------
PARAMETER         CURRENT_VALUE
Type              openjdk18
Application       app
Project           myproject
SourceType        binary
Ref
SourceLocation    target/wildwest-1.0.jar
Ports             8080/TCP,8443/TCP,8778/TCP
Name              backend
MinMemory
MaxMemory
DebugPort
Ignore
MinCPU
MaxCPU
---- 

Since backend is a binary component, as specified in the odo create command above, changes to the component's source code should be followed by pushing the jar file to a running container. After mvn compiled a new wildwest-1.0.jar file, the program would be deployed to OpenShift with the odo push command. We can execute such a push right now:

[source,bash]
----
$ odo push
Validation
 ✓  Checking component [6ms]

Configuration changes
 ✓  Initializing component
 ✓  Creating component [124ms]

Pushing to component backend of type binary
 ✓  Checking files for pushing [1ms]
 ✓  Waiting for component to start [48s]
 ✓  Syncing files to the component [811ms]
 ✓  Building component [3s]
---- 


Using `odo push`, OpenShift has created a container to host the backend component, deployed the container into a pod running on the OpenShift cluster, and started up the `backend` component.
 
If you want to check on the status of an action in odo, you can use the `odo log -f` command:

[source,bash]
----
odo log -f
---- 

After the component has been deployed, you can again run `odo log` to see the current status of the application:

[source,bash]
----
2019-09-30 20:14:19.738  INFO 444 --- [           main] c.o.wildwest.WildWestApplication         : Starting WildWestApplication v1.0 onbackend-app-1-9tnhc with PID 444 (/deployments/wildwest-1.0.jar started by jboss in /deployments)
----

The backend jar file has now been pushed, and the backend component is now running:

[source,bash]
----
$ odo list
APP     NAME        TYPE          SOURCE                             STATE
app     backend     openjdk18     file://target/wildwest-1.0.jar     Pushed
----

== Deploying the front-end source code

Change directories to the frontend directory:

[source,bash]
----
$ cd ..
$ cd ~/frontend
---- 

Listing the contents of this directory shows that frontend is a Node.js application.

[source,bash]
----
$ ls
assets  bin  index.html  kwww-frontend.iml  package.json  package-lock.json  playfield.png  README.md  server.js
---- 

Since the frontend component is written in an interpreted language (Node.js), there is no build step analogous to the Maven build we performed for the backend component. We can proceed directly to specifying the nodejs environment from the cluster's software catalog.

We give this Node.js component the name frontend:

[source,bash]
----
$ odo create nodejs frontend
 ✓  Validating component [5ms]
Please use `odo push` command to create the component with source deployed
---- 

With the component named and the config file created, we can push the Node.js source code from the current directory:

[source,bash]
----
$ odo push
Validation
 ✓  Checking component [8ms]

Configuration changes
 ✓  Initializing component
 ✓  Creating component [83ms]

Pushing to component frontend of type local
 ✓  Checking files for pushing [2ms]
 ✓  Waiting for component to start [45s]
 ✓  Syncing files to the component [3s]
 ✓  Building component [18s]
 ✓  Changes successfully pushed to component
----

Once the deployment finishes, you'll see the pod become available within OpenShift. When the pod becomes available, the frontend component has now been deployed and is running on a container on OpenShift.

== Linking both components

With both components of our application running on the cluster, we need to connect them so they can communicate. OpenShift provides mechanisms to publish communication bindings from a program to its clients. This is referred to as linking.

First, let's see all the components we have available to us:

[source,bash]
----
$ odo list
APP     NAME         TYPE          SOURCE                             STATE
app     backend      openjdk18     file://target/wildwest-1.0.jar     Pushed
app     frontend     nodejs        file://./                          Pushed
----


To link the current frontend component to the backend, you can run:

[source,bash]
----
$ odo link backend --port 8080
 ✓  Component backend has been successfully linked from the component frontend

Following environment variables were added to frontend component:
- COMPONENT_BACKEND_HOST
- COMPONENT_BACKEND_PORT
----

This will inject configuration information into the frontend about the backend and then restart the frontend component.

Now that the frontend component has been linked with the backend component, let's make frontend publicly accessible.

== Exposing components to the public

We have updated frontend to be linked with backend to allow our application's components to communicate. Let's now create an external URL for our application so we can see it in action:

[source,bash]
----
$ cd frontend
$ odo url create frontend --port 8080
 ✓  URL frontend created for component: frontend

To create URL on the OpenShift Cluster, please use `odo push`
---- 

The change can now be pushed:

[source,bash]
----
$ odo push
Validation
 ✓  Checking component [21ms]

Configuration changes
 ✓  Retrieving component data [35ms]
 ✓  Applying configuration [29ms]

Applying URL changes
 ✓  URL frontend: http://frontend-app-myproject.192.168.42.79.nip.io created

Pushing to component frontend of type local
 ✓  Checking file changes for pushing [1ms]
 ✓  No file changes detected, skipping build. Use the '-f' flag to force the build.
---- 

Visit the URL in your browser to view the application once the odo push command finishes.

==== Important note regarding the game

The game requires permission to the active Service Account in order access the OpenShift namespace and delete active / current pods.This error may occur when looking at `odo log` from the backend component:

[source,bash]
----
Message: Forbidden!Configured service account doesn't have access. Service account may have been revoked..]
----

Permissions for the Service Account role is required. It is *not* recommended to do this on a product cluster:

[source,bash]
----
$ oc policy add-role-to-group view system:serviceaccounts -n <project>
$ oc policy add-role-to-group edit system:serviceaccounts -n <project>
----

=== Making live changes to your source-code

We've deployed the first version of our application and tested it by visiting it with a browser. Let's look at how OpenShift and odo help make it easier to iterate on that app once it's running.

First, make sure you are still in the frontend directory:

[source,bash]
----
$ cd ~/frontend
----

Now, we will tell odo to watch for changes on the file system in the background. In a separate terminal, type:

[source,bash]
----
$ odo watch 
----

Let's change the displayed name for our wild west game. Currently, the title is "Wild West Shoot 'em Up!" We will change this to "My App Shoot 'em Up!"

Edit the file index.html with a search-and-replace one-liner performed with the Unix stream editor, sed:

[source,bash]
----
$ sed -i "s/Wild West/My App/" index.html
----
 
There may be a slight delay before odorecognizes the change. Once the change is recognized, odo will push the changes to the frontend component and print its status to the terminal:

[source,bash]
----
File /root/frontend/index.html changed
File  changed
Pushing files...
 ✓  Waiting for component to start
 ✓  Copying files to component
 ✓  Building component
----

Refresh the application's page in the web browser. You will see the new name in the web interface for the application.
